// simulate non-self recognition S-RNase based GSI
initialize() {
	initializeSLiMModelType("nonWF");
	defineConstant("K", 100); // carrying capacity
	defineConstant("N", 500); // pop size -- 
	defineConstant("FB", 10); // number of F-boxes -- same as number of haplotypes until redundancy is encoded
	defineConstant("num_hap", 5); // number of functioning S-haplotypes to start the simulation.  Must be less than or equal to FB, until redundancy is encoded.
	defineConstant("cross_grains", 9); // number of outcrossed pollen grains a mom samples in one reproduction() callback
	defineConstant("self_grains", 1); // number of self pollen grains within each mom's pollen sample
	initializeMutationType("m1", 0.5, "f", 0.0); // neutral
	initializeMutationType("m2", 0.5, "f", 0.0); // gain of function S-RNase
	initializeMutationType("m3", 0.5, "f", 0.0); // loss of function S-RNase
	initializeMutationType("m4", 0.5, "f", 0.0); // gain of function F-Boxes
	initializeMutationType("m5", 0.5, "f", 0.0); // loss of function F-Boxes
	initializeMutationType("m6", 0.0, "f", -0.9); // deleterious
	// Define the mutation rate here so it can be easily manipulated
	defineConstant("mu", 1e-7);
	
	// Define the scaling factor for deleterious mutations
	defineConstant("mult", 10.0);
	// Define the generations in which delta should be calculated
	defineConstant('deltaSchedule', c(10100, 10200, 10300, 10400, 10500));
	
	// Define a constant, unpurgeable fitness penalty for all selfed offspring
	defineConstant('constantDelta', 0.0);
	
	// g1 genomic element type: uses m1 for all mutations (non S-locus)
	initializeGenomicElementType("g1", c(m6), c(mult));
	// g2 genomic element type: uses m1, m2, and m3 mutations (S-RNase)
	initializeGenomicElementType("g2", c(m1,m2,m3), c(0.0000000001, 1.0, 1.0));
	// g3 genomic element type: uses m1, m4, and m5 mutations (F-Boxes)
	initializeGenomicElementType("g3", c(m1,m4,m5), c(0.0000000001, 1.0, 1.0));
	// g4 genomic element type: uses m1 mutations (intergenic regions in S-locus)
	initializeGenomicElementType("g4", c(m1), c(0.0000000001));
	// Set up genome
	// user defined total length of genome (0 based)
	genome_length = 99999;
	// user defined number of chromosomes -- this will be hardcoded for now
	num_chrs = 4;
	// user defined number of f-boxes -- this will also be the number of possible haplotypes (until we code redundancy)
	num_fboxes = FB;
	// user defined size of S-RNase locus.  Solanaceae S-RNase exons span ~680 bp -- not sure how this corresponds to SLiM genome space.
	srnase_length = 500;
	// user defined size of F-box loci.  F-boxes lack introns and span 1-1.2kb.   
	fbox_length = 500;
	// user defined size of intergenic space.  I have no good estimate of what this should be?
	intergenic_length = 100;
	// chrom ends -- hardcoded based on the number of chromosomes assigned above
	chrom_ends = c(24999, 25000, 49999, 50000, 74999, 75000, 99999);
	// free recombination between chromosomal endpoints
	chrom_rates = c(1e-09, 0.5, 1e-09, 0.5, 1e-09, 0.5, 1e-09);
	// pick S-locus to be on chr 1 -- this is arbitrary but will make bookkeeping easier if additional chromosomes are added.	
	// draw random starting point for S-RNase
	srnase_start = asInteger(12500 - srnase_length);
	// find S-RNase end
	srnase_end = asInteger(srnase_start + srnase_length);
	// initialize S-RNase locus
	initializeGenomicElement(g2, srnase_start, srnase_end); // S-RNase
	locus_end = srnase_end;
	locus_start = srnase_start;
	i = 0;
	fbox_starts = c();
	fbox_ends = c();
	placement = 0;
	while(i <= (FB - 1)){
		if(placement == 0){
			start1=asInteger(locus_start - intergenic_length);
			end1 = asInteger(locus_start - 1);
			initializeGenomicElement(g4, start1, end1);	// place intergenic space
			//keep track of start and end of new f-box
			start2=asInteger(locus_start - intergenic_length - fbox_length);
			end2=asInteger(locus_start - intergenic_length-1);
			//initialize new f-box
			initializeGenomicElement(g3, start2, end2);
			// keep track of all start and ends for f-box loci
			fbox_starts = c(fbox_starts, locus_start - intergenic_length - fbox_length);
			fbox_ends = c(fbox_ends, locus_start - intergenic_length - 1);
			// update leading edge of S-locus
			locus_start = asInteger(locus_start - intergenic_length - fbox_length);
			placement = 1;
		}
		else{
			// keep track of start and end of integenic space
			start1=asInteger(locus_end + 1);
			end1 = asInteger(locus_end + intergenic_length);
			// initialize intergenic space
			initializeGenomicElement(g4, start1, end1);
			// keep track of start and end of new F-box
			start2 = asInteger(locus_end + intergenic_length + 1);
			end2 = asInteger(start2 + fbox_length);
			// initialize new f-box
			initializeGenomicElement(g3, start2, end2);
			// keep track of all start and ends for f-box loci
			fbox_starts = c(fbox_starts, locus_end + intergenic_length + 1);
			fbox_ends = c(fbox_ends, locus_end + intergenic_length + fbox_length);
			// update trailing edge of S-locus
			locus_end = locus_end + intergenic_length + fbox_length + 1;
			placement = 0;
		}
		i = i + 1;
	}
	
	// initialize non S-genome
	initializeGenomicElement(g1, 0, asInteger(locus_start -1));
	initializeGenomicElement(g1, asInteger(locus_end + 1), genome_length);
	
	// set recombination breakpoints -- no recombination or mutation within S-locus (for now)
	recomb_ends = c(asInteger(locus_start), asInteger(locus_end), chrom_ends);
	recomb_rates = c(1e-9, 0, chrom_rates);
	mut_rates = rep(mu, length(recomb_rates));
	
	//mut_ends=sort(c(fbox_ends, fbox_starts, srnase_start, srnase_end, genome_length));
	//		ends=asInteger(c(locus_start, locus_end, genome_length));
	//		mut_rates = c(1e-7, 1e-7, 1e-7);
	//		recomb_rates = c(1e-8, 0, 1e-8);
	initializeMutationRate(mut_rates, recomb_ends);
	initializeRecombinationRate(recomb_rates, recomb_ends);
	// create F-box dictionary
	fbox_dict1 = cbind(asInteger(seq(from = 0, to = num_fboxes-1)), asInteger(fbox_starts), asInteger(fbox_ends));
	print(fbox_dict1);
	defineConstant("fbox_dict", fbox_dict1);
	defineConstant("srnase_range", asInteger(c(srnase_start, srnase_end)));
	defineConstant("breaks", recomb_ends);
	// Initialize files for the fitness of the selfed and outcrossed offspring
	h = paste(c('fitness'), sep = ',');
	writeFile("self-fit.csv", h, append = F);
	writeFile("out-fit.csv", h, append = F);
}


// load in burnin pop
1 early(){
	sim.readFromPopulationFile("no_sheltered_burnin_100K_500N_10FB_5num_hap_9cross_grains_1self_grains_1e-07mu_10000mult.txt");
	// load in the mutation file
	mut_file = readFile("mut_no_sheltered_burnin_100K_500N_10FB_5num_hap_9cross_grains_1self_grains_1e-07mu_10000mult.txt");
	// loop through each line and assign tags for each mutation
	for(i in 1:(length(mut_file)-1)){
		line = strsplit(mut_file[i], sep = ",");
		matching_mut = sim.mutations[sim.mutations.id == line[1]];
		matching_mut.tag = asInteger(line[2]);
	}
	// If there's more than one subpopulation, get rid of the others
	if(length(sim.subpopulations) > 1){
		sim.subpopulations[1:(length(sim.subpopulations)-1)].removeSubpopulation();
	}
}


// do reproduction
reproduction(){
	// get S-RNase specificity of focal reproduction() plant
	style_muts1=genome1.mutationsOfType(m2);
	// do same for genome2	
	style_muts2=genome2.mutationsOfType(m2);
	// Only the youngest style GOF affects specificity
	style_gof1_gen = max(style_muts1.originGeneration);
	style_gof2_gen = max(style_muts2.originGeneration);
	style_muts1 = style_muts1[which(style_muts1.originGeneration == style_gof1_gen)];
	style_muts2 = style_muts2[which(style_muts2.originGeneration == style_gof2_gen)];
	// Specificities are defined by RNase tags
	style_spec1=style_muts1.tag;
	style_spec2=style_muts2.tag;
	// Find the style loss of function mutations
	style_lofs1=genome1.mutationsOfType(m3);
	style_lofs2=genome2.mutationsOfType(m3);
	// Figure out when the youngest style LOF occurred on each genome.
	// If there are no LOFs, convert their origin generation from NULL to -1
	if(size(style_lofs1.originGeneration) < 1) style_lof1_gen = -1;
	else style_lof1_gen = max(style_lofs1.originGeneration);
	if(size(style_lofs2.originGeneration) < 1) style_lof2_gen = -1;
	else style_lof2_gen = max(style_lofs2.originGeneration);
	//If there is a newer loss of function than gain of function, set the style specificity to the special value of -1
	if(style_lof1_gen > style_gof1_gen)
		style_spec1 = -1;
	//	else style_spec1=srnase_dict[which(srnase_dict[,0] == style_muts1.position),2];
	if(style_lof2_gen > style_gof2_gen)
		style_spec2 = -1;
	//else style_spec2=srnase_dict[which(srnase_dict[,0] == style_muts2.position),2];
	style_specs=c(style_spec1, style_spec2);
	
	// each individual reproduces itself once -- determine how many offspring focal individual will have
	nOff=rpois(1, 5);
	// sample plants from subppop to be pollen parents -- 
	cross_pollen_parents=p1.sampleIndividuals(cross_grains, replace = T); // allowing replacement allows full sibs
	pollen_parents = c(cross_pollen_parents, rep(individual, self_grains)); // add self pollen
	//	pollen_parents = sample(pollen_parents, replace = F); // shuffle self and cross pollen just in case
	// get pollen specificities for each parent in pollen subsample
	for(dad in pollen_parents){
		// get pollen mutations
		pollen_muts1=dad.genome1.mutationsOfType(m4).position;
		pollen_muts2=dad.genome2.mutationsOfType(m4).position;
		// get pollen specifities
		// assign pollen specificities
		pmut1_spec = c();
		for(pos in pollen_muts1){
			pmut1_spec = c(pmut1_spec, fbox_dict[which(pos >= fbox_dict[,1] & pos <= fbox_dict[,2]),0]);
		}
		pmut2_spec = c();
		for(pos in pollen_muts2){
			pmut2_spec = c(pmut2_spec, fbox_dict[which(pos >= fbox_dict[,1] & pos <= fbox_dict[,2]),0]);
		}
		// check compatibility
		// for compatibility the F-box pollen specs (for each genome), must match/contain BOTH s-rnase specs of the focal individual
		if(style_specs[0] == -1) // If the first RNase is broken, both pollen haplotypes are automatically compatible
		{
			pollen1_comp1 = T;
			pollen2_comp1 = T;
		}
		else
		{
			pollen1_comp1=any(style_specs[0] == pmut1_spec);
			pollen2_comp1=any(style_specs[0] == pmut2_spec);
		}
		if(style_specs[1] == -1) // If the second RNase is broken, both pollen haplotypes are automatically compatible
		{
			pollen1_comp2 = T;
			pollen2_comp2 = T;
		}
		else
		{
			pollen1_comp2=any(style_specs[1] == pmut1_spec);
			pollen2_comp2=any(style_specs[1] == pmut2_spec);
		}
		pollen1_comp = pollen1_comp1 & pollen1_comp2;
		pollen2_comp = pollen2_comp1 & pollen2_comp2;
		// tag genomes of pollen parents 1 == compatible, 0 == incompatible
		if(pollen1_comp == T) dad.genome1.tag=1;
		if(pollen1_comp == F) dad.genome1.tag=0;
		if(pollen2_comp == T) dad.genome2.tag=1;
		if(pollen2_comp == F) dad.genome2.tag=0;
		// tag pollen individuals with sum of their genome tags -- this will make it so we don't waste time with completely incompatible matings.  
		dad.tag=sum(c(dad.genome1.tag, dad.genome2.tag));
	}
	// don't waste time on incompatible pollen		
	if(sum(pollen_parents.tag) != 0){
		// make offspring.  
		for(k in seqLen(nOff)){
			//grab a sire			
			sire = sample(pollen_parents, 1, weights = pollen_parents.tag);
			//if sire is fully compatible, sample random genome from sire and make recombinant
			if(sire.genome1.tag == 1 & sire.genome2.tag == 1){
				rando_sire=rbinom(1, 1, 0.5);
				if(rando_sire == 0) child = p1.addRecombinant(individual.genome1, individual.genome2, breaks, sire.genome1, NULL, NULL);
				if(rando_sire == 1) child = p1.addRecombinant(individual.genome1, individual.genome2, breaks, sire.genome2, NULL, NULL);
				// apply fitness penalty to selfed offspring
				if(sire == individual) child.fitnessScaling = 1 - constantDelta;
			}
			// if only genome1 from sire is compatible, take random genome from dam and genome1 from sire to make recombinant
			if(sire.genome1.tag == 1 & sire.genome2.tag == 0){
				child = p1.addRecombinant(individual.genome1, individual.genome2, breaks, sire.genome1, NULL, NULL);
				// apply fitness penalty to selfed offspring
				if(sire == individual) child.fitnessScaling = 1 - constantDelta;
			}
			//if only genome2 from sire is compatible, take random genome from dam and genome2 from sire to make recombinant
			if(sire.genome1.tag == 0 & sire.genome2.tag == 1){
				child = p1.addRecombinant(individual.genome1, individual.genome2, breaks, sire.genome2, NULL, NULL);
				// apply fitness penalty to selfed offspring
				if(sire == individual) child.fitnessScaling = 1 - constantDelta;
			}
			// if sire is incompatible it shouldn't be here, but kill the kid just in case
			if(sire.genome1.tag == 0 & sire.genome2.tag == 0){
				dead_kid = p1.addEmpty();
				dead_kid.fitnessScaling = 0;
			}
		}
	}
	else{}
}

// tag new S-RNase mutations with 99999
mutation(m2) {
	mut.tag = 99999;
	return T;
}

early() {
	// provide density-dependent selection so the non-WF model doesn't get out of control
	p1.fitnessScaling = K / sum(p1.individuals.age > 0);
	
	// check if a new mutation is here.  If so print out a message
	if(any(sim.mutationsOfType(m2).tag == 99999)){
		num_new = length(sim.mutationsOfType(m2)[which(sim.mutationsOfType(m2).tag == 99999)]);
		print("gnoob(s)");
		// For each new RNase GOF, randomly pick a specificity from RNase space
		news = sample(1:FB, num_new, replace = T);
		sim.mutationsOfType(m2)[which(sim.mutationsOfType(m2).tag == 99999)].tag = news;
		cat("current S-RNase specifities are: \n");
		print(sim.mutationsOfType(m2).tag);
	}
}

///////////////////////
/// CALCULATE DELTA ///
///////////////////////

10000:19999 late() {
	if(any(sim.generation == (deltaSchedule-1))){
		// Create a subpopulation just for selfed offspring
		sim.addSubpop('p100', 0);
		// Create a subpopulation just for outcrossed offspring
		sim.addSubpop('p200', 0);
	}
}

// Make selfed offspring for calculating inbreeding depression
10000:19999 reproduction(p1) {
	if(any(sim.generation == (deltaSchedule))){
		// Select 1000 random individuals in p1 to self one time each
		self_parents = sample(p1.individuals, 1000, replace = T);
		for(i in self_parents){
			p100.addSelfed(i);
		}
		self.active = 0; // Turn off the callback after running once
	}
}
// Make outcrossed offspring for calculating inbreeding depression
10000:19999 reproduction(p1) {
	if(any(sim.generation == (deltaSchedule))){
		// Select 1000 random pairs to produce one outcrossed offspring each
		moms = sample(p1.individuals, 1000, replace = T);
		dads = sample(p1.individuals, 1000, replace = T);
		for(i in 0:999){
			p200.addCrossed(moms[i], dads[i]);
		}
		self.active = 0; // Turn off the callback after running once
	}
}
// Calculate fitness of the selfed individuals for inbreeding depression
10000:19999 fitness(NULL, p100) { // On an individual-by-individual basis
	if(any(sim.generation == (deltaSchedule))){
		del_muts = individual.genomes.mutationsOfType(m6);
		effs = c(); // Fitness effects of each mutation (hetero- or homozygous)
		//    print(individual.countOfMutationsOfType(m6));
		for(m in del_muts){
			// Determine if the individual is heterozygous or homozygous for this mutation
			isHomozygous = individual.genome1.containsMutations(m) & individual.genome2.containsMutations(m);
			// Define s; thanks to Chris on the SLiM Google Group for making this robust to gamma DFEs
			s = max(m.selectionCoeff,-1.0);
			// Heterozygous mutations
			if(!isHomozygous){
				effs = c(effs, s*m.mutationType.dominanceCoeff);
			}
			// Homomzygous mutations
			if(isHomozygous){
				effs = c(effs, s);
			}
		}
		// Calculate the individual's overall fitness and save it to self-fit
		if(size(del_muts) < 1){
			w = asFloat(1);
		}
		else{
			w = asFloat(product(1 + effs));
		}
		individual.tagF = w;
		//                Output fitness of this selfed offspring
		if(w < 10^(-300)){
			w = 0.0;
		}
		out = paste(c(w), sep = ",");
		writeFile("self-fit.csv", out, append = T);
		return(1.0);
	}
}
// Calculate fitness of the outcrossed individuals for inbreeding depression
10000:19999 fitness(NULL, p200) { // On an individual-by-individual basis
	if(any(sim.generation == (deltaSchedule))){
		del_muts = individual.genomes.mutationsOfType(m6);
		effs = c(); // Fitness effects of each mutation (hetero- or homozygous)
		//      print(individual.countOfMutationsOfType(m6));
		for(m in del_muts){
			// Determine if the individual is heterozygous or homozygous for this mutation
			isHomozygous = individual.genome1.containsMutations(m) & individual.genome2.containsMutations(m);
			// Define s; thanks to Chris on the SLiM Google Group for making this robust to gamma DFEs
			s = max(m.selectionCoeff,-1.0);
			// Heterozygous mutations
			if(!isHomozygous){
				effs = c(effs, s*m.mutationType.dominanceCoeff);
			}
			// Homomzygous mutations
			if(isHomozygous){
				effs = c(effs, s);
			}
		}
		// Calculate the individual's overall fitness and save it to out-fit
		if(size(del_muts) < 1){
			w = asFloat(1);
		}
		else{
			w = asFloat(product(1 + effs));
		}
		individual.tagF = w;
		//              Output fitness of this outcrossed offspring
		if(w < 10^(-300)){
			w = 0.0;
		}
		out = paste(c(w), sep = ",");
		writeFile("out-fit.csv", out, append = T);
		return(1.0);
	}
}

////////////////////////////////
/// FINISH CALCULATING DELTA ///
////////////////////////////////

10000:19999 late(){
	if(any(sim.generation == (deltaSchedule))){
		// Calculate and print delta
		self_fit = readFile("self-fit.csv");
		self_fit = self_fit[1:(length(self_fit)-1)];
		self_fit = asFloat(self_fit);
		out_fit = readFile("out-fit.csv");
		out_fit = out_fit[1:(length(out_fit)-1)];
		out_fit = asFloat(out_fit);
		delta = 1 - mean(self_fit)/mean(out_fit);
		delta_message = paste(c("Delta =", delta), sep = ' ');
		print(delta_message);
		// Overwrite the self- and out-fit.csv files
		h = paste(c('fitness'), sep = ',');
		writeFile("self-fit.csv", h, append = F);
		writeFile("out-fit.csv", h, append = F);
		// Remove excess subpopulations
		if(length(sim.subpopulations) > 1){
			sim.subpopulations[1:(length(sim.subpopulations)-1)].removeSubpopulation();
		}
	}
}

20000 late(){
	// make final S-RNase dictionary
	smuts=sim.mutationsOfType(m2);
	srnase_dict=cbind(smuts.position, smuts.id, smuts.tag, smuts.originGeneration);
	cat("Final S-RNase dictionary: \n");
	cat("Position, ID, tag, originGeneration \n");
	print(srnase_dict);
	cat("S-RNase muts: \n");
	sim.outputMutations(sim.mutationsOfType(m2));
	cat("F-Box muts: \n");
	sim.outputMutations(sim.mutationsOfType(m4));
}
